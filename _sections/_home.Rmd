```{r include-logos, echo=FALSE, results='asis'}

# Local logo paths (change to relative paths to share/publish the report)
logo_paths <- c(
    'logos/NEC-logo-1000.jpg',
    'logos/BSPH.logo.rgb_horizontal.blue.png',
    'logos/ACCIDDALogoSmall.png'
)

# Build <img> tags using data URIs and emit as raw HTML placed at top of page
img_tags <- vapply(logo_paths, FUN.VALUE = "", FUN = function(p) {
  if (!file.exists(p)) {
    message("Logo file not found (skipping): ", p)
    return("")
  }
  uri <- knitr::image_uri(p)
  alt <- tools::file_path_sans_ext(basename(p))
  sprintf('<img src="%s" alt="%s" />', uri, alt)
})
img_tags <- img_tags[nzchar(img_tags)]

if (length(img_tags) == 0) {
  message("No logos emitted: check file paths.")
} else {
  html <- paste0('<div class="rpt-top-logos">', paste(img_tags, collapse = "\n"), '</div>')
  knitr::asis_output(html)
}

```

<br>

```{r cdc-rt-trend-maps-with-paired-summaries, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
# Paired layout: for each disease emit a single row with a left summary box and the choropleth on the right. Uses the CDC "Epidemic Trends and Rt" dataset.

# --- User config ---
states_to_show <- c("Arizona", "Colorado", "New Mexico", "Utah")
# keywords used to match CDC disease names; order must match summary_bullets
diseases_to_plot <- c("covid", "influenza", "rsv")

# USER-PROVIDED summary bullets (inserted exactly as requested)
summary_bullets <- c(
    "The current COVID epidemic trend (based on data reported through 1/20/2026) is **declining** for Arizona, is **likely declining** for Colorado, and is not currently estimated for New Mexico or Utah. The weekly percentage of ED visits diagnosed with COVID was **low** for Colorado and New Mexico and **very low** for Arizona and Utah.",
  
  "The current flu epidemic trend (based on data reported through 1/20/2026) is **not changing** for Colorado, is **growing** for Arizona, and is not currently estimated for New Mexico or Utah. The weekly percentage of ED visits diagnosed with RSV was **low** for Arizona and **moderate** for Colorado, New Mexico, and Utah.",
  
    "The current RSV epidemic trend (based on data reported through 1/20/2026) is **likely growing** for Arizona, is **growing** for Colorado, and is not currently estimated for New Mexico or Utah. The weekly percentage of ED visits diagnosed with RSV was **low** for Arizona, Colorado, New Mexico, and Utah."
)
# --------------------

# small CSS so each summary box visually matches the plot height and spacing
cat("<style>
/* container for a paired row */
.pair-row { margin-bottom: 14px; }

/* left summary box (one per disease) */
.summary-item {
  border: 1px solid #cfe6ff;
  background: linear-gradient(180deg,#ffffff,#f4fbff);
  padding: 0.75rem 0.5rem;
  margin-bottom: 0;
  border-radius: 6px;
  box-shadow: 0 1px 2px rgba(31,119,180,0.04);
  min-height: 320px;            /* approximate height to match map */
  display: flex;
  flex-direction: column;
  justify-content: center;
}

/* heading inside summary box */
.summary-item h4 {
  margin: 0 0 0.35rem 0;
  font-size: 0rem;
  color: #0f3b61;
}

/* body text */
.summary-item p {
  margin: 0;
  font-size: 1.5rem;
  line-height: 1.45;
}

/* responsive: reduce box height on small screens so stacking looks better */
@media (max-width: 767px) {
  .summary-item { min-height: 120px; margin-bottom: 10px; }
}

</style>", sep = "")

# --- Download & prepare CDC dataset ---
cdc_csv_url <- "https://data.cdc.gov/api/views/5dqz-y4ea/rows.csv?accessType=DOWNLOAD"
rt_raw <- read_csv(cdc_csv_url, col_types = cols(.default = "c"))

# detect the most likely date column name
possible_date_names <- c("week_end", "week_ending", "week_end_date", "week", "week_end_dt",
                         "date", "as_of", "issue_date", "report_date", "time_value")
date_col <- NULL
for (p in possible_date_names) {
  m <- grep(p, tolower(names(rt_raw)), value = TRUE)
  if (length(m) > 0) { date_col <- m[1]; break }
}
if (is.null(date_col)) stop("Could not detect date column. Run names(rt_raw) to inspect columns.")

# parse dates robustly
rt_raw[[date_col]] <- parse_date_time(rt_raw[[date_col]],
                                      orders = c("Y-m-d", "m/d/Y", "Ymd", "m/d/Y HMS", "Y-m-d HMS"),
                                      exact = FALSE)
rt_raw[[date_col]] <- as.Date(rt_raw[[date_col]])

# detect state / disease / trend columns
state_col <- names(rt_raw)[which(grepl("^state$|location|geo|jurisdiction", tolower(names(rt_raw))))][1]
disease_col_candidates <- names(rt_raw)[which(grepl("disease|virus|pathogen|syndrom", tolower(names(rt_raw))))]
disease_col <- if (length(disease_col_candidates) > 0) disease_col_candidates[1] else NA_character_
trend_col_candidates <- names(rt_raw)[which(grepl("trend|category|status|epidemic", tolower(names(rt_raw))))]
trend_col <- if (length(trend_col_candidates) > 0) trend_col_candidates[1] else NA_character_

if (is.na(state_col) || is.null(state_col)) stop("Could not detect state column. Run names(rt_raw).")

# normalize columns
rt_df <- rt_raw %>%
  rename(rt_date = !!sym(date_col),
         rt_state = !!sym(state_col)) %>%
  mutate(disease_raw = if (!is.na(disease_col)) .data[[disease_col]] else NA_character_,
         trend_raw   = if (!is.na(trend_col))  .data[[trend_col]]  else NA_character_)

# helper: canonical levels and normalizer
desired_levels <- c("Growing","Likely Growing","Not Changing","Likely Declining","Declining","Not Estimated")
normalize_trend <- function(x) {
  x <- tolower(trimws(as.character(x)))
  x[x %in% c("","na","n/a","not estimated","not_estimated","not available","<na>")] <- NA_character_
  res <- sapply(x, function(xx) {
    if (is.na(xx) || xx=="") return("Not Estimated")
    if (str_detect(xx,"likely") && str_detect(xx,"grow")) return("Likely Growing")
    if (str_detect(xx,"grow") && !str_detect(xx,"likely")) return("Growing")
    if (str_detect(xx,"likely") && str_detect(xx,"declin|down")) return("Likely Declining")
    if (str_detect(xx,"declin|down") && !str_detect(xx,"likely")) return("Declining")
    if (str_detect(xx,"not chang|no change|stable|steady|unchanged|flat")) return("Not Changing")
    if (xx %in% tolower(desired_levels)) return(str_to_title(xx))
    return("Not Estimated")
  }, USE.NAMES = FALSE)
  factor(res, levels = desired_levels, ordered = TRUE)
}

# map polygons
us_map <- map_data("state")

# Helper to get USPS state abbreviations robustly
get_state_abbrev <- function(x) {
  sapply(x, function(s) {
    if (is.na(s) || trimws(as.character(s)) == "") return(NA_character_)
    s_trim <- trimws(as.character(s))
    up <- toupper(s_trim)
    # If already a valid 2-letter postal code, return it
    if (nchar(up) == 2 && up %in% state.abb) return(up)
    # Exact full name match (case-insensitive)
    idx <- match(tolower(s_trim), tolower(state.name), nomatch = 0)
    if (idx > 0) return(state.abb[idx])
    # Some inputs might be e.g. "Ariz." or partial; try to find a substring match
    match_idx <- which(str_detect(tolower(state.name), fixed(tolower(s_trim))))
    if (length(match_idx) >= 1) return(state.abb[match_idx[1]])
    # District of Columbia / DC
    if (tolower(s_trim) %in% c("district of columbia", "dc")) return("DC")
    # Fallback: return uppercase first two letters (keeps previous behavior for unknowns)
    toupper(substr(s_trim, 1, 2))
  }, USE.NAMES = FALSE)
}

# plotting helper that uses the most recent week for the given disease
plot_for_disease <- function(keyword, requested_states) {
  # select disease rows (with alias fallback)
  if (!all(is.na(rt_df$disease_raw))) {
    disease_rows <- rt_df %>% filter(!is.na(disease_raw) & str_detect(tolower(disease_raw), fixed(tolower(keyword))))
    if (nrow(disease_rows) == 0) {
      alias_map <- list(covid = c("covid","sars-cov-2","covid-19","covid19"),
                        influenza = c("influenza","flu"),
                        rsv = c("rsv"))
      aliases <- alias_map[[keyword]]
      if (!is.null(aliases)) disease_rows <- rt_df %>% filter(!is.na(disease_raw) & sapply(tolower(disease_raw), function(x) any(str_detect(x, paste(aliases, collapse="|")))))
    }
  } else {
    disease_rows <- rt_df
  }

  # get latest date for this disease across dataset
  if (nrow(disease_rows) == 0 || all(is.na(disease_rows$rt_date))) {
    latest_date <- NA
  } else {
    latest_date <- max(disease_rows$rt_date, na.rm = TRUE)
  }

  # take rows for that date; ensure one row per requested state (missing -> NA)
  if (!is.na(latest_date)) {
    df_sub <- disease_rows %>% filter(rt_date == latest_date)
  } else {
    df_sub <- tibble(disease_raw = NA_character_, rt_state = requested_states, rt_date = as.Date(NA), trend_raw = NA_character_)
  }

  requested <- tibble(rt_state = requested_states)

  df_sub2 <- requested %>%
    left_join(df_sub %>% select(rt_state, rt_date, trend_raw, disease_raw), by = "rt_state") %>%
    mutate(trend_raw = ifelse(is.na(trend_raw), NA_character_, trend_raw),
           rt_date = as.Date(rt_date))

  df_sub2 <- df_sub2 %>% mutate(trend = normalize_trend(trend_raw))

  # ensure trend factor has full set of desired levels and explicit "Not Estimated" for missing
  df_sub2 <- df_sub2 %>%
    mutate(trend = as.character(trend)) %>%
    mutate(trend = ifelse(is.na(trend), "Not Estimated", trend)) %>%
    mutate(trend = factor(trend, levels = desired_levels, ordered = TRUE))

  # region mapping for join
  if (all(tolower(df_sub2$rt_state) %in% tolower(state.name))) {
    df_sub2 <- df_sub2 %>% mutate(region = tolower(rt_state))
  } else if (all(toupper(df_sub2$rt_state) %in% state.abb)) {
    abbr_to_name <- setNames(tolower(state.name), state.abb)
    df_sub2 <- df_sub2 %>% mutate(region = abbr_to_name[toupper(rt_state)])
  } else {
    df_sub2 <- df_sub2 %>% rowwise() %>%
      mutate(region = {
        candidate <- tolower(rt_state)
        if (candidate %in% tolower(state.name)) candidate else {
          match_idx <- which(str_detect(tolower(state.name), fixed(candidate)))
          if (length(match_idx) > 0) tolower(state.name[match_idx[1]]) else if (toupper(rt_state) %in% state.abb) tolower(state.name[which(state.abb == toupper(rt_state))[1]]) else NA_character_
        }
      }) %>% ungroup()
  }

  map_joined <- us_map %>% left_join(df_sub2 %>% select(region, trend, rt_date, rt_state), by = c("region" = "region"))

  # ensure trend factor on map_joined has full set of desired levels
  map_joined <- map_joined %>%
    mutate(trend = as.character(trend)) %>%
    mutate(trend = ifelse(is.na(trend), "Not Estimated", trend)) %>%
    mutate(trend = factor(trend, levels = desired_levels, ordered = TRUE))

  # dummy data to force all legend levels (positions are arbitrary and placed off-map)
  legend_force_df <- tibble::tibble(
    .x = seq_len(length(desired_levels)) + 9999,    # far outside map coords
    .y = seq_len(length(desired_levels)) + 9999,
    trend = factor(desired_levels, levels = desired_levels, ordered = TRUE)
  )

  # bounding box & centroids
  regions_to_keep <- tolower(requested_states)
  bbox_df <- map_joined %>% filter(region %in% regions_to_keep)
  centroids <- map_joined %>%
    group_by(region) %>%
    summarize(long = mean(range(long)), lat = mean(range(lat)),
              trend = first(trend), rt_state = first(rt_state), .groups = "drop") %>%
    # add USPS abbreviation column using the robust helper
    mutate(state_abbr = get_state_abbrev(rt_state))

  trend_colors <- c("Growing" = "#d73027", "Likely Growing" = "#fc8d59", "Not Changing" = "#ffffbf",
                    "Likely Declining" = "#91cf60", "Declining" = "#1a9850", "Not Estimated" = "#d9d9d9")

  p <- ggplot() +
    geom_polygon(data = us_map %>% filter(!region %in% unique(map_joined$region)),
                 aes(x = long, y = lat, group = group),
                 fill = "grey95", color = "white", size = 0.2) +
    geom_polygon(data = map_joined,
                 aes(x = long, y = lat, group = group, fill = trend),
                 color = "grey40", size = 0.25) +
    # invisible dummy points placed far off the map so they never show; show.legend = TRUE so they create legend keys
    geom_point(data = legend_force_df,
               aes(x = .x, y = .y, fill = trend),
               shape = 21, size = 6, color = NA, alpha = 0, show.legend = TRUE) +
    geom_text(data = centroids %>% filter(region %in% regions_to_keep),
              aes(x = long, y = lat, label = state_abbr),
              size = 4, fontface = "bold") +
    scale_fill_manual(values = trend_colors,
                      limits = desired_levels,
                      breaks = desired_levels,
                      drop = FALSE,
                      na.value = trend_colors["Not Estimated"],
                      name = "Epidemic Trends") +
    # override.aes restores visible filled-square legend keys (alpha=1 here so keys are not transparent)
    guides(fill = guide_legend(override.aes = list(shape = 22, size = 6, colour = "grey40", alpha = 1), ncol = 1)) +
    coord_quickmap(xlim = range(bbox_df$long, na.rm = TRUE) + c(-1.2, 1.2),
                   ylim = range(bbox_df$lat, na.rm = TRUE) + c(-1.0, 1.0)) +
    theme_minimal(base_size = 14) +
    labs(title = toupper(keyword),
         subtitle = paste0("Selected states: ", paste(requested_states, collapse = ", "),
                           " | Latest dataset date: ", ifelse(is.na(latest_date), "Not available", format(latest_date, "%Y-%m-%d"))),
         caption = "Source: CDC 'Epidemic Trends and Rt' (data.cdc.gov, dataset 5dqz-y4ea)") +
    theme(axis.title = element_blank(), axis.text = element_blank(), panel.grid = element_blank(), legend.position = "right")

  p
}

# Build plots
plots_list <- lapply(diseases_to_plot, function(k) plot_for_disease(k, states_to_show))

# Emit per-disease paired rows: left small box (summary), right map
if(knitr::is_html_output()) {
  for (i in seq_along(diseases_to_plot)) {
    
    cat('<div class="row pair-row">')
    
    # left column: summary for this disease
    cat('<div class="col-md-4">')
    cat(sprintf('<div class="summary-item"><h4>%s</h4><p>%s</p></div>', toupper(diseases_to_plot[i]), summary_bullets[i]))
    cat('</div>')
    
    # right column: plot for this disease
    cat('<div class="col-md-8 plot-wrap">')
    print(plots_list[[i]])
    cat('</div>')
    
    cat('</div>') # close pair row
  }
} else {
  for (i in seq_along(diseases_to_plot)) {
    cat("\n\n")
    cat("### ", toupper(diseases_to_plot[i]), "\n\n")
    cat(summary_bullets[i], "\n\n")
    print(plots_list[[i]])
    cat("\n\n\\newpage\n\n")  # optional: one disease per page
  }
}

```
